<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>mu: mu::Vector&lt; N, T &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">mu
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classmu_1_1Vector.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pro-attribs">Protected Attributes</a> &#124;
<a href="#friends">Friends</a> &#124;
<a href="classmu_1_1Vector-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">mu::Vector&lt; N, T &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>A generic vector.  
 <a href="classmu_1_1Vector.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="vector_8h_source.html">vector.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:a4ce6dcb3e505735626b86b354fea6f25"><td class="memItemLeft" align="right" valign="top"><a id="a4ce6dcb3e505735626b86b354fea6f25"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>value_type</b> = typename std::array&lt; T, N &gt;::value_type</td></tr>
<tr class="separator:a4ce6dcb3e505735626b86b354fea6f25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77a0701fbf49d9228243aebeba5321a7"><td class="memItemLeft" align="right" valign="top"><a id="a77a0701fbf49d9228243aebeba5321a7"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>size_type</b> = typename std::array&lt; T, N &gt;::size_type</td></tr>
<tr class="separator:a77a0701fbf49d9228243aebeba5321a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe8fe07337f6975a7ef048342ba670f5"><td class="memItemLeft" align="right" valign="top"><a id="afe8fe07337f6975a7ef048342ba670f5"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>iterator</b> = typename std::array&lt; T, N &gt;::iterator</td></tr>
<tr class="separator:afe8fe07337f6975a7ef048342ba670f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae38655506ed500c38fb0a4db83b9af0"><td class="memItemLeft" align="right" valign="top"><a id="aae38655506ed500c38fb0a4db83b9af0"></a>
using&#160;</td><td class="memItemRight" valign="bottom"><b>const_iterator</b> = typename std::array&lt; T, N &gt;::const_iterator</td></tr>
<tr class="separator:aae38655506ed500c38fb0a4db83b9af0"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7931e7af478ad36f64e196dade093c30"><td class="memItemLeft" align="right" valign="top"><a id="a7931e7af478ad36f64e196dade093c30"></a>
constexpr&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmu_1_1Vector.html#a7931e7af478ad36f64e196dade093c30">Vector</a> ()=default</td></tr>
<tr class="memdesc:a7931e7af478ad36f64e196dade093c30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="classmu_1_1Vector.html" title="A generic vector. ">Vector</a> object. <br /></td></tr>
<tr class="separator:a7931e7af478ad36f64e196dade093c30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1811fcd0b41864a64127eb82c7b699d"><td class="memTemplParams" colspan="2">template&lt;typename... TArgs&gt; </td></tr>
<tr class="memitem:ae1811fcd0b41864a64127eb82c7b699d"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmu_1_1Vector.html#ae1811fcd0b41864a64127eb82c7b699d">Vector</a> (TArgs &amp;&amp;... args)</td></tr>
<tr class="memdesc:ae1811fcd0b41864a64127eb82c7b699d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="classmu_1_1Vector.html" title="A generic vector. ">Vector</a> object from an amount of N values.  <a href="#ae1811fcd0b41864a64127eb82c7b699d">More...</a><br /></td></tr>
<tr class="separator:ae1811fcd0b41864a64127eb82c7b699d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1fd85178491c5d9b5b67468bbed29e33"><td class="memTemplParams" colspan="2">template&lt;std::size_t Nn, class U &gt; </td></tr>
<tr class="memitem:a1fd85178491c5d9b5b67468bbed29e33"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmu_1_1Vector.html#a1fd85178491c5d9b5b67468bbed29e33">Vector</a> (const <a class="el" href="classmu_1_1Vector.html">Vector</a>&lt; Nn, U &gt; &amp;v)</td></tr>
<tr class="memdesc:a1fd85178491c5d9b5b67468bbed29e33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="classmu_1_1Vector.html" title="A generic vector. ">Vector</a> from an existing <a class="el" href="classmu_1_1Vector.html" title="A generic vector. ">Vector</a> of a different type.  <a href="#a1fd85178491c5d9b5b67468bbed29e33">More...</a><br /></td></tr>
<tr class="separator:a1fd85178491c5d9b5b67468bbed29e33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37d9bc2c4e9c085ff813c8f7a59fa629"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmu_1_1Vector.html#a37d9bc2c4e9c085ff813c8f7a59fa629">Vector</a> (const std::array&lt; T, N &gt; &amp;a)</td></tr>
<tr class="memdesc:a37d9bc2c4e9c085ff813c8f7a59fa629"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="classmu_1_1Vector.html" title="A generic vector. ">Vector</a> object from an std::array.  <a href="#a37d9bc2c4e9c085ff813c8f7a59fa629">More...</a><br /></td></tr>
<tr class="separator:a37d9bc2c4e9c085ff813c8f7a59fa629"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8cf1a96dfed8a52ec7abc54029f240c"><td class="memTemplParams" colspan="2">template&lt;typename U  = T, std::enable_if_t&lt; std::is_arithmetic_v&lt; U &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:af8cf1a96dfed8a52ec7abc54029f240c"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmu_1_1Vector.html#af8cf1a96dfed8a52ec7abc54029f240c">Vector</a> (const std::array&lt; U, N &gt; &amp;a)</td></tr>
<tr class="memdesc:af8cf1a96dfed8a52ec7abc54029f240c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="classmu_1_1Vector.html" title="A generic vector. ">Vector</a> object from an std::array of a different type.  <a href="#af8cf1a96dfed8a52ec7abc54029f240c">More...</a><br /></td></tr>
<tr class="separator:af8cf1a96dfed8a52ec7abc54029f240c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8eaa13db8e49bc60779bb8bcc7c958b"><td class="memTemplParams" colspan="2">template&lt;typename U  = T, std::enable_if_t&lt; std::is_arithmetic_v&lt; U &gt;, int &gt;  = 0&gt; </td></tr>
<tr class="memitem:ac8eaa13db8e49bc60779bb8bcc7c958b"><td class="memTemplItemLeft" align="right" valign="top">&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmu_1_1Vector.html#ac8eaa13db8e49bc60779bb8bcc7c958b">Vector</a> (const U &amp;value)</td></tr>
<tr class="memdesc:ac8eaa13db8e49bc60779bb8bcc7c958b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="classmu_1_1Vector.html" title="A generic vector. ">Vector</a> object from a single value.  <a href="#ac8eaa13db8e49bc60779bb8bcc7c958b">More...</a><br /></td></tr>
<tr class="separator:ac8eaa13db8e49bc60779bb8bcc7c958b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40a06506c5feb65d38bb1586d3dab393"><td class="memItemLeft" align="right" valign="top"><a id="a40a06506c5feb65d38bb1586d3dab393"></a>
&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmu_1_1Vector.html#a40a06506c5feb65d38bb1586d3dab393">~Vector</a> ()=default</td></tr>
<tr class="memdesc:a40a06506c5feb65d38bb1586d3dab393"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the <a class="el" href="classmu_1_1Vector.html" title="A generic vector. ">Vector</a> object. <br /></td></tr>
<tr class="separator:a40a06506c5feb65d38bb1586d3dab393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0685dd9a3b39d92caa55c7e2f4336e37"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmu_1_1Vector.html#a0685dd9a3b39d92caa55c7e2f4336e37">Vector</a> (const <a class="el" href="classmu_1_1Vector.html">Vector</a> &amp;other)=default</td></tr>
<tr class="memdesc:a0685dd9a3b39d92caa55c7e2f4336e37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy construct a new <a class="el" href="classmu_1_1Vector.html" title="A generic vector. ">Vector</a> object.  <a href="#a0685dd9a3b39d92caa55c7e2f4336e37">More...</a><br /></td></tr>
<tr class="separator:a0685dd9a3b39d92caa55c7e2f4336e37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3a6a139b333da003ccfc49c01bf60eb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmu_1_1Vector.html#ad3a6a139b333da003ccfc49c01bf60eb">Vector</a> (<a class="el" href="classmu_1_1Vector.html">Vector</a> &amp;&amp;other) noexcept=default</td></tr>
<tr class="memdesc:ad3a6a139b333da003ccfc49c01bf60eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move construct a new <a class="el" href="classmu_1_1Vector.html" title="A generic vector. ">Vector</a> object.  <a href="#ad3a6a139b333da003ccfc49c01bf60eb">More...</a><br /></td></tr>
<tr class="separator:ad3a6a139b333da003ccfc49c01bf60eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3c1a60d0cf755ac49f65b4bdd79e19c"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmu_1_1Vector.html">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmu_1_1Vector.html#ad3c1a60d0cf755ac49f65b4bdd79e19c">operator=</a> (const <a class="el" href="classmu_1_1Vector.html">Vector</a> &amp;other)=default</td></tr>
<tr class="memdesc:ad3c1a60d0cf755ac49f65b4bdd79e19c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy assignment operator.  <a href="#ad3c1a60d0cf755ac49f65b4bdd79e19c">More...</a><br /></td></tr>
<tr class="separator:ad3c1a60d0cf755ac49f65b4bdd79e19c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2797ec19947823a5464a6c1b42b7a707"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmu_1_1Vector.html">Vector</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmu_1_1Vector.html#a2797ec19947823a5464a6c1b42b7a707">operator=</a> (<a class="el" href="classmu_1_1Vector.html">Vector</a> &amp;&amp;other) noexcept=default</td></tr>
<tr class="memdesc:a2797ec19947823a5464a6c1b42b7a707"><td class="mdescLeft">&#160;</td><td class="mdescRight">Move assignment operator.  <a href="#a2797ec19947823a5464a6c1b42b7a707">More...</a><br /></td></tr>
<tr class="separator:a2797ec19947823a5464a6c1b42b7a707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6be2cb910ade8cd39f922e23c6c3a69e"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmu_1_1Vector.html#a6be2cb910ade8cd39f922e23c6c3a69e">operator[]</a> (size_type idx) noexcept</td></tr>
<tr class="memdesc:a6be2cb910ade8cd39f922e23c6c3a69e"><td class="mdescLeft">&#160;</td><td class="mdescRight">access an element within the vector  <a href="#a6be2cb910ade8cd39f922e23c6c3a69e">More...</a><br /></td></tr>
<tr class="separator:a6be2cb910ade8cd39f922e23c6c3a69e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cfd9124c9143e0cddacf54733169b68"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmu_1_1Vector.html#a3cfd9124c9143e0cddacf54733169b68">operator[]</a> (size_type idx) const noexcept</td></tr>
<tr class="memdesc:a3cfd9124c9143e0cddacf54733169b68"><td class="mdescLeft">&#160;</td><td class="mdescRight">const access an element within the vector  <a href="#a3cfd9124c9143e0cddacf54733169b68">More...</a><br /></td></tr>
<tr class="separator:a3cfd9124c9143e0cddacf54733169b68"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29173887541bdface45e662338f25d44"><td class="memItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmu_1_1Vector.html#a29173887541bdface45e662338f25d44">at</a> (size_type idx)</td></tr>
<tr class="memdesc:a29173887541bdface45e662338f25d44"><td class="mdescLeft">&#160;</td><td class="mdescRight">access an element within the vector  <a href="#a29173887541bdface45e662338f25d44">More...</a><br /></td></tr>
<tr class="separator:a29173887541bdface45e662338f25d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a722613947d35b97a32f930ef6b70c364"><td class="memItemLeft" align="right" valign="top">const T &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmu_1_1Vector.html#a722613947d35b97a32f930ef6b70c364">at</a> (size_type idx) const</td></tr>
<tr class="memdesc:a722613947d35b97a32f930ef6b70c364"><td class="mdescLeft">&#160;</td><td class="mdescRight">const access an element within the vector  <a href="#a722613947d35b97a32f930ef6b70c364">More...</a><br /></td></tr>
<tr class="separator:a722613947d35b97a32f930ef6b70c364"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a6c382df2038bb89209087f1df0d60c"><td class="memItemLeft" align="right" valign="top">constexpr size_type&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmu_1_1Vector.html#a1a6c382df2038bb89209087f1df0d60c">size</a> () const noexcept</td></tr>
<tr class="memdesc:a1a6c382df2038bb89209087f1df0d60c"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns the size of the vector  <a href="#a1a6c382df2038bb89209087f1df0d60c">More...</a><br /></td></tr>
<tr class="separator:a1a6c382df2038bb89209087f1df0d60c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d9d1c3218082522712fea2d5bc32868"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmu_1_1Vector.html#a7d9d1c3218082522712fea2d5bc32868">begin</a> () noexcept</td></tr>
<tr class="separator:a7d9d1c3218082522712fea2d5bc32868"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab02fae7a5770b7980686695979b99a74"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmu_1_1Vector.html#ab02fae7a5770b7980686695979b99a74">begin</a> () const noexcept</td></tr>
<tr class="separator:ab02fae7a5770b7980686695979b99a74"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2caa4d33d64d146ca8c101d5005e025e"><td class="memItemLeft" align="right" valign="top">iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmu_1_1Vector.html#a2caa4d33d64d146ca8c101d5005e025e">end</a> () noexcept</td></tr>
<tr class="separator:a2caa4d33d64d146ca8c101d5005e025e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c733864c02356902b5d92e8fe2cd56c"><td class="memItemLeft" align="right" valign="top">const_iterator&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmu_1_1Vector.html#a3c733864c02356902b5d92e8fe2cd56c">end</a> () const noexcept</td></tr>
<tr class="separator:a3c733864c02356902b5d92e8fe2cd56c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57ac0fa3add5609d667d37b934793acd"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmu_1_1Vector.html#a57ac0fa3add5609d667d37b934793acd">min</a> () const</td></tr>
<tr class="memdesc:a57ac0fa3add5609d667d37b934793acd"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the min value of the vector  <a href="#a57ac0fa3add5609d667d37b934793acd">More...</a><br /></td></tr>
<tr class="separator:a57ac0fa3add5609d667d37b934793acd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bcb8df801149ed1a5654a141aae14d7"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmu_1_1Vector.html#a0bcb8df801149ed1a5654a141aae14d7">max</a> () const</td></tr>
<tr class="memdesc:a0bcb8df801149ed1a5654a141aae14d7"><td class="mdescLeft">&#160;</td><td class="mdescRight">get the max value of the vector  <a href="#a0bcb8df801149ed1a5654a141aae14d7">More...</a><br /></td></tr>
<tr class="separator:a0bcb8df801149ed1a5654a141aae14d7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5aaede8fa7e0cfa50b044fcaf89cf1f2"><td class="memItemLeft" align="right" valign="top">T&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmu_1_1Vector.html#a5aaede8fa7e0cfa50b044fcaf89cf1f2">sum</a> () const</td></tr>
<tr class="memdesc:a5aaede8fa7e0cfa50b044fcaf89cf1f2"><td class="mdescLeft">&#160;</td><td class="mdescRight">sum up all the elements of the vector  <a href="#a5aaede8fa7e0cfa50b044fcaf89cf1f2">More...</a><br /></td></tr>
<tr class="separator:a5aaede8fa7e0cfa50b044fcaf89cf1f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21538d374825d19f7ce70a6649c03418"><td class="memTemplParams" colspan="2">template&lt;typename U  = T&gt; </td></tr>
<tr class="memitem:a21538d374825d19f7ce70a6649c03418"><td class="memTemplItemLeft" align="right" valign="top">U&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmu_1_1Vector.html#a21538d374825d19f7ce70a6649c03418">mean</a> () const</td></tr>
<tr class="memdesc:a21538d374825d19f7ce70a6649c03418"><td class="mdescLeft">&#160;</td><td class="mdescRight">mean of all the elements of the vector  <a href="#a21538d374825d19f7ce70a6649c03418">More...</a><br /></td></tr>
<tr class="separator:a21538d374825d19f7ce70a6649c03418"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f7031194349b2570aeb0ef17fca454b"><td class="memTemplParams" colspan="2">template&lt;typename U  = void, std::size_t N2, typename T2 &gt; </td></tr>
<tr class="memitem:a9f7031194349b2570aeb0ef17fca454b"><td class="memTemplItemLeft" align="right" valign="top">std::conditional_t&lt; std::is_same_v&lt; U, void &gt;, T, U &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmu_1_1Vector.html#a9f7031194349b2570aeb0ef17fca454b">dot</a> (const <a class="el" href="classmu_1_1Vector.html">Vector</a>&lt; N2, T2 &gt; &amp;rhs) const</td></tr>
<tr class="memdesc:a9f7031194349b2570aeb0ef17fca454b"><td class="mdescLeft">&#160;</td><td class="mdescRight">dot product of two vectors  <a href="#a9f7031194349b2570aeb0ef17fca454b">More...</a><br /></td></tr>
<tr class="separator:a9f7031194349b2570aeb0ef17fca454b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b18c0e720a71db992888f483efad627"><td class="memTemplParams" colspan="2"><a id="a6b18c0e720a71db992888f483efad627"></a>
template&lt;typename U  = void, std::size_t N2, std::size_t M2, typename T2 &gt; </td></tr>
<tr class="memitem:a6b18c0e720a71db992888f483efad627"><td class="memTemplItemLeft" align="right" valign="top">std::conditional_t&lt; std::is_same_v&lt; U, void &gt;, <a class="el" href="classmu_1_1Vector.html">Vector</a>&lt; M2, T &gt;, <a class="el" href="classmu_1_1Vector.html">Vector</a>&lt; M2, U &gt; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>dot</b> (const <a class="el" href="classmu_1_1Matrix.html">Matrix</a>&lt; N2, M2, T2 &gt; &amp;rhs) const</td></tr>
<tr class="separator:a6b18c0e720a71db992888f483efad627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa706bb810519c20ff759be4661d26371"><td class="memTemplParams" colspan="2">template&lt;class U  = T&gt; </td></tr>
<tr class="memitem:aa706bb810519c20ff759be4661d26371"><td class="memTemplItemLeft" align="right" valign="top">U&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmu_1_1Vector.html#aa706bb810519c20ff759be4661d26371">std</a> () const</td></tr>
<tr class="memdesc:aa706bb810519c20ff759be4661d26371"><td class="mdescLeft">&#160;</td><td class="mdescRight">calculates the standard deviation  <a href="#aa706bb810519c20ff759be4661d26371">More...</a><br /></td></tr>
<tr class="separator:aa706bb810519c20ff759be4661d26371"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe4d3c4dfa03eb4c8f9240f89c7f6139"><td class="memTemplParams" colspan="2">template&lt;class U  = T&gt; </td></tr>
<tr class="memitem:afe4d3c4dfa03eb4c8f9240f89c7f6139"><td class="memTemplItemLeft" align="right" valign="top">U&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmu_1_1Vector.html#afe4d3c4dfa03eb4c8f9240f89c7f6139">length</a> () const</td></tr>
<tr class="memdesc:afe4d3c4dfa03eb4c8f9240f89c7f6139"><td class="mdescLeft">&#160;</td><td class="mdescRight">euclidean vector length  <a href="#afe4d3c4dfa03eb4c8f9240f89c7f6139">More...</a><br /></td></tr>
<tr class="separator:afe4d3c4dfa03eb4c8f9240f89c7f6139"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a597ca2de6348a91e896f3f2296a5bcd2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmu_1_1Vector.html#a597ca2de6348a91e896f3f2296a5bcd2">flip</a> ()</td></tr>
<tr class="memdesc:a597ca2de6348a91e896f3f2296a5bcd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">flips this vector, i.e. reverses its elements  <a href="#a597ca2de6348a91e896f3f2296a5bcd2">More...</a><br /></td></tr>
<tr class="separator:a597ca2de6348a91e896f3f2296a5bcd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4cc2ef12039a1bc51b8e048a48054b49"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmu_1_1Vector.html">Vector</a>&lt; N, T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmu_1_1Vector.html#a4cc2ef12039a1bc51b8e048a48054b49">flipped</a> () const</td></tr>
<tr class="memdesc:a4cc2ef12039a1bc51b8e048a48054b49"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a flipped vector  <a href="#a4cc2ef12039a1bc51b8e048a48054b49">More...</a><br /></td></tr>
<tr class="separator:a4cc2ef12039a1bc51b8e048a48054b49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3274e01fb6a31b8e750ef2bd32cf61a3"><td class="memItemLeft" align="right" valign="top"><a id="a3274e01fb6a31b8e750ef2bd32cf61a3"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmu_1_1Vector.html#a3274e01fb6a31b8e750ef2bd32cf61a3">sort</a> ()</td></tr>
<tr class="memdesc:a3274e01fb6a31b8e750ef2bd32cf61a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">sort vector elements in ascending order <br /></td></tr>
<tr class="separator:a3274e01fb6a31b8e750ef2bd32cf61a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a345ca284147c9d01c541548256c67a49"><td class="memTemplParams" colspan="2">template&lt;typename Compare &gt; </td></tr>
<tr class="memitem:a345ca284147c9d01c541548256c67a49"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmu_1_1Vector.html#a345ca284147c9d01c541548256c67a49">sort</a> (const Compare &amp;comp)</td></tr>
<tr class="memdesc:a345ca284147c9d01c541548256c67a49"><td class="mdescLeft">&#160;</td><td class="mdescRight">sort vector elements by providing a condition  <a href="#a345ca284147c9d01c541548256c67a49">More...</a><br /></td></tr>
<tr class="separator:a345ca284147c9d01c541548256c67a49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a268fadef8c3774945acc651f22d18e16"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classmu_1_1Vector.html">Vector</a>&lt; N, T &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classmu_1_1Vector.html#a268fadef8c3774945acc651f22d18e16">sorted</a> () const</td></tr>
<tr class="memdesc:a268fadef8c3774945acc651f22d18e16"><td class="mdescLeft">&#160;</td><td class="mdescRight">returns a sorted vector  <a href="#a268fadef8c3774945acc651f22d18e16">More...</a><br /></td></tr>
<tr class="separator:a268fadef8c3774945acc651f22d18e16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbcfbe6e288f4e4087dbc36f4579dce0"><td class="memTemplParams" colspan="2">template&lt;typename Compare &gt; </td></tr>
<tr class="memitem:adbcfbe6e288f4e4087dbc36f4579dce0"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmu_1_1Vector.html">Vector</a>&lt; N, T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmu_1_1Vector.html#adbcfbe6e288f4e4087dbc36f4579dce0">sorted</a> (const Compare &amp;comp) const</td></tr>
<tr class="separator:adbcfbe6e288f4e4087dbc36f4579dce0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a727d9670b23f8e43004ce09096b3bed0"><td class="memTemplParams" colspan="2">template&lt;typename U  = T&gt; </td></tr>
<tr class="memitem:a727d9670b23f8e43004ce09096b3bed0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmu_1_1Vector.html#a727d9670b23f8e43004ce09096b3bed0">operator==</a> (const <a class="el" href="classmu_1_1Vector.html">Vector</a>&lt; N, U &gt; &amp;rhs) const</td></tr>
<tr class="memdesc:a727d9670b23f8e43004ce09096b3bed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">equality operator  <a href="#a727d9670b23f8e43004ce09096b3bed0">More...</a><br /></td></tr>
<tr class="separator:a727d9670b23f8e43004ce09096b3bed0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba86af220137e62f96c70b633655406d"><td class="memTemplParams" colspan="2">template&lt;typename U  = T&gt; </td></tr>
<tr class="memitem:aba86af220137e62f96c70b633655406d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmu_1_1Vector.html#aba86af220137e62f96c70b633655406d">operator!=</a> (const <a class="el" href="classmu_1_1Vector.html">Vector</a>&lt; N, U &gt; &amp;rhs) const</td></tr>
<tr class="memdesc:aba86af220137e62f96c70b633655406d"><td class="mdescLeft">&#160;</td><td class="mdescRight">unequality operator  <a href="#aba86af220137e62f96c70b633655406d">More...</a><br /></td></tr>
<tr class="separator:aba86af220137e62f96c70b633655406d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2136aad610ab276d4dc903fc83a7278c"><td class="memTemplParams" colspan="2">template&lt;typename U  = T&gt; </td></tr>
<tr class="memitem:a2136aad610ab276d4dc903fc83a7278c"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmu_1_1Vector.html">Vector</a>&lt; N, T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmu_1_1Vector.html#a2136aad610ab276d4dc903fc83a7278c">operator+=</a> (const <a class="el" href="classmu_1_1Vector.html">Vector</a>&lt; N, U &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a2136aad610ab276d4dc903fc83a7278c"><td class="mdescLeft">&#160;</td><td class="mdescRight">plus equal operator  <a href="#a2136aad610ab276d4dc903fc83a7278c">More...</a><br /></td></tr>
<tr class="separator:a2136aad610ab276d4dc903fc83a7278c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aa6f7aa9010b7da656a88500f7fe543"><td class="memTemplParams" colspan="2">template&lt;typename U  = T&gt; </td></tr>
<tr class="memitem:a2aa6f7aa9010b7da656a88500f7fe543"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmu_1_1Vector.html">Vector</a>&lt; N, T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmu_1_1Vector.html#a2aa6f7aa9010b7da656a88500f7fe543">operator-=</a> (const <a class="el" href="classmu_1_1Vector.html">Vector</a>&lt; N, U &gt; &amp;rhs)</td></tr>
<tr class="memdesc:a2aa6f7aa9010b7da656a88500f7fe543"><td class="mdescLeft">&#160;</td><td class="mdescRight">minus equal operator  <a href="#a2aa6f7aa9010b7da656a88500f7fe543">More...</a><br /></td></tr>
<tr class="separator:a2aa6f7aa9010b7da656a88500f7fe543"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb469ba14b1c71a664c89a2718111cd3"><td class="memTemplParams" colspan="2">template&lt;typename U  = T&gt; </td></tr>
<tr class="memitem:acb469ba14b1c71a664c89a2718111cd3"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmu_1_1Vector.html">Vector</a>&lt; N, T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmu_1_1Vector.html#acb469ba14b1c71a664c89a2718111cd3">operator*=</a> (const <a class="el" href="classmu_1_1Vector.html">Vector</a>&lt; N, U &gt; &amp;rhs)</td></tr>
<tr class="memdesc:acb469ba14b1c71a664c89a2718111cd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">multiplication equal operator  <a href="#acb469ba14b1c71a664c89a2718111cd3">More...</a><br /></td></tr>
<tr class="separator:acb469ba14b1c71a664c89a2718111cd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa790abe736d6907382139e21fc29fa73"><td class="memTemplParams" colspan="2">template&lt;typename U  = T&gt; </td></tr>
<tr class="memitem:aa790abe736d6907382139e21fc29fa73"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="classmu_1_1Vector.html">Vector</a>&lt; N, T &gt; &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmu_1_1Vector.html#aa790abe736d6907382139e21fc29fa73">operator/=</a> (const <a class="el" href="classmu_1_1Vector.html">Vector</a>&lt; N, U &gt; &amp;rhs)</td></tr>
<tr class="memdesc:aa790abe736d6907382139e21fc29fa73"><td class="mdescLeft">&#160;</td><td class="mdescRight">divison equal operator  <a href="#aa790abe736d6907382139e21fc29fa73">More...</a><br /></td></tr>
<tr class="separator:aa790abe736d6907382139e21fc29fa73"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa19ffa96f0ea27c8c25fc854c50e18f7"><td class="memTemplParams" colspan="2">template&lt;class TScalar &gt; </td></tr>
<tr class="memitem:aa19ffa96f0ea27c8c25fc854c50e18f7"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_arithmetic_v&lt; TScalar &gt;, <a class="el" href="classmu_1_1Vector.html">Vector</a>&lt; N, T &gt; &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmu_1_1Vector.html#aa19ffa96f0ea27c8c25fc854c50e18f7">operator+=</a> (const TScalar &amp;scalar)</td></tr>
<tr class="memdesc:aa19ffa96f0ea27c8c25fc854c50e18f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">add a scalar to this vector  <a href="#aa19ffa96f0ea27c8c25fc854c50e18f7">More...</a><br /></td></tr>
<tr class="separator:aa19ffa96f0ea27c8c25fc854c50e18f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00853b170ad61e3e0e662de55ed0e8db"><td class="memTemplParams" colspan="2">template&lt;class TScalar &gt; </td></tr>
<tr class="memitem:a00853b170ad61e3e0e662de55ed0e8db"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_arithmetic_v&lt; TScalar &gt;, <a class="el" href="classmu_1_1Vector.html">Vector</a>&lt; N, T &gt; &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmu_1_1Vector.html#a00853b170ad61e3e0e662de55ed0e8db">operator-=</a> (const TScalar &amp;scalar)</td></tr>
<tr class="memdesc:a00853b170ad61e3e0e662de55ed0e8db"><td class="mdescLeft">&#160;</td><td class="mdescRight">subtract a scalar from every element of this vector  <a href="#a00853b170ad61e3e0e662de55ed0e8db">More...</a><br /></td></tr>
<tr class="separator:a00853b170ad61e3e0e662de55ed0e8db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5414c8c1ccbc49de284c9814c1abe5ff"><td class="memTemplParams" colspan="2">template&lt;class TScalar &gt; </td></tr>
<tr class="memitem:a5414c8c1ccbc49de284c9814c1abe5ff"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_arithmetic_v&lt; TScalar &gt;, <a class="el" href="classmu_1_1Vector.html">Vector</a>&lt; N, T &gt; &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmu_1_1Vector.html#a5414c8c1ccbc49de284c9814c1abe5ff">operator*=</a> (const TScalar &amp;scalar)</td></tr>
<tr class="memdesc:a5414c8c1ccbc49de284c9814c1abe5ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">multiply a scalar with this vector  <a href="#a5414c8c1ccbc49de284c9814c1abe5ff">More...</a><br /></td></tr>
<tr class="separator:a5414c8c1ccbc49de284c9814c1abe5ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bc39f40d0f048d6586d3f5a4107bc52"><td class="memTemplParams" colspan="2">template&lt;class TScalar &gt; </td></tr>
<tr class="memitem:a3bc39f40d0f048d6586d3f5a4107bc52"><td class="memTemplItemLeft" align="right" valign="top">std::enable_if_t&lt; std::is_arithmetic_v&lt; TScalar &gt;, <a class="el" href="classmu_1_1Vector.html">Vector</a>&lt; N, T &gt; &amp; &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmu_1_1Vector.html#a3bc39f40d0f048d6586d3f5a4107bc52">operator/=</a> (const TScalar &amp;scalar)</td></tr>
<tr class="memdesc:a3bc39f40d0f048d6586d3f5a4107bc52"><td class="mdescLeft">&#160;</td><td class="mdescRight">divide every element of this vector by a scalar  <a href="#a3bc39f40d0f048d6586d3f5a4107bc52">More...</a><br /></td></tr>
<tr class="separator:a3bc39f40d0f048d6586d3f5a4107bc52"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr class="memitem:ab69c10480bdde6f434244271de791219"><td class="memItemLeft" align="right" valign="top"><a id="ab69c10480bdde6f434244271de791219"></a>
std::array&lt; T, N &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>data_</b></td></tr>
<tr class="separator:ab69c10480bdde6f434244271de791219"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:ab10e7bdb6528c96a682b563532eeb6a2"><td class="memTemplParams" colspan="2">template&lt;std::size_t Nn, class U &gt; </td></tr>
<tr class="memitem:ab10e7bdb6528c96a682b563532eeb6a2"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classmu_1_1Vector.html#ab10e7bdb6528c96a682b563532eeb6a2">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="classmu_1_1Vector.html">Vector</a>&lt; Nn, U &gt; &amp;v)</td></tr>
<tr class="memdesc:ab10e7bdb6528c96a682b563532eeb6a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">print vector values  <a href="#ab10e7bdb6528c96a682b563532eeb6a2">More...</a><br /></td></tr>
<tr class="separator:ab10e7bdb6528c96a682b563532eeb6a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;std::size_t N, typename T&gt;<br />
class mu::Vector&lt; N, T &gt;</h3>

<p>A generic vector. </p>
<p>Can be instantiated with an arithmetic type as defined by the standard library.</p><ul>
<li>implementation-defined extended integer types, including any signed, unsigned, and cv-qualified variants. (bool, char, int, long ...)</li>
<li>implementation-defined extended floating-point types including any cv-qualified variants. (float, double, long double)</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">N</td><td>size </td></tr>
    <tr><td class="paramname">T</td><td>type </td></tr>
  </table>
  </dd>
</dl>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="ae1811fcd0b41864a64127eb82c7b699d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1811fcd0b41864a64127eb82c7b699d">&#9670;&nbsp;</a></span>Vector() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename T&gt; </div>
<div class="memtemplate">
template&lt;typename... TArgs&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmu_1_1Vector.html">mu::Vector</a>&lt; N, T &gt;::<a class="el" href="classmu_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">TArgs &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new <a class="el" href="classmu_1_1Vector.html" title="A generic vector. ">Vector</a> object from an amount of N values. </p>
<p>the amount of values must match the static size of this <a class="el" href="classmu_1_1Vector.html" title="A generic vector. ">Vector</a></p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TArgs</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">args</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1fd85178491c5d9b5b67468bbed29e33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1fd85178491c5d9b5b67468bbed29e33">&#9670;&nbsp;</a></span>Vector() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename T&gt; </div>
<div class="memtemplate">
template&lt;std::size_t Nn, class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmu_1_1Vector.html">mu::Vector</a>&lt; N, T &gt;::<a class="el" href="classmu_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmu_1_1Vector.html">Vector</a>&lt; Nn, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new <a class="el" href="classmu_1_1Vector.html" title="A generic vector. ">Vector</a> from an existing <a class="el" href="classmu_1_1Vector.html" title="A generic vector. ">Vector</a> of a different type. </p>
<p>implicit narrowing may be applied it is checked that the <a class="el" href="classmu_1_1Vector.html" title="A generic vector. ">Vector</a> sizes are the same</p>
<p>Example: </p><div class="fragment"><div class="line"><a class="code" href="classmu_1_1Vector.html">mu::Vector&lt;2, int&gt;</a> a = {1, 2};</div><div class="line"><a class="code" href="classmu_1_1Vector.html">mu::Vector&lt;2, double&gt;</a> b = {a};</div></div><!-- fragment --><dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Nn</td><td></td></tr>
    <tr><td class="paramname">U</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">v</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a37d9bc2c4e9c085ff813c8f7a59fa629"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37d9bc2c4e9c085ff813c8f7a59fa629">&#9670;&nbsp;</a></span>Vector() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmu_1_1Vector.html">mu::Vector</a>&lt; N, T &gt;::<a class="el" href="classmu_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; T, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new <a class="el" href="classmu_1_1Vector.html" title="A generic vector. ">Vector</a> object from an std::array. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af8cf1a96dfed8a52ec7abc54029f240c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8cf1a96dfed8a52ec7abc54029f240c">&#9670;&nbsp;</a></span>Vector() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename T&gt; </div>
<div class="memtemplate">
template&lt;typename U  = T, std::enable_if_t&lt; std::is_arithmetic_v&lt; U &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmu_1_1Vector.html">mu::Vector</a>&lt; N, T &gt;::<a class="el" href="classmu_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const std::array&lt; U, N &gt; &amp;&#160;</td>
          <td class="paramname"><em>a</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new <a class="el" href="classmu_1_1Vector.html" title="A generic vector. ">Vector</a> object from an std::array of a different type. </p>
<p>implicit narrowing may be applied</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">a</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac8eaa13db8e49bc60779bb8bcc7c958b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac8eaa13db8e49bc60779bb8bcc7c958b">&#9670;&nbsp;</a></span>Vector() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename T&gt; </div>
<div class="memtemplate">
template&lt;typename U  = T, std::enable_if_t&lt; std::is_arithmetic_v&lt; U &gt;, int &gt;  = 0&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmu_1_1Vector.html">mu::Vector</a>&lt; N, T &gt;::<a class="el" href="classmu_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const U &amp;&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Construct a new <a class="el" href="classmu_1_1Vector.html" title="A generic vector. ">Vector</a> object from a single value. </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">value</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0685dd9a3b39d92caa55c7e2f4336e37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0685dd9a3b39d92caa55c7e2f4336e37">&#9670;&nbsp;</a></span>Vector() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmu_1_1Vector.html">mu::Vector</a>&lt; N, T &gt;::<a class="el" href="classmu_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmu_1_1Vector.html">Vector</a>&lt; N, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy construct a new <a class="el" href="classmu_1_1Vector.html" title="A generic vector. ">Vector</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad3a6a139b333da003ccfc49c01bf60eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3a6a139b333da003ccfc49c01bf60eb">&#9670;&nbsp;</a></span>Vector() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmu_1_1Vector.html">mu::Vector</a>&lt; N, T &gt;::<a class="el" href="classmu_1_1Vector.html">Vector</a> </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmu_1_1Vector.html">Vector</a>&lt; N, T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move construct a new <a class="el" href="classmu_1_1Vector.html" title="A generic vector. ">Vector</a> object. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a29173887541bdface45e662338f25d44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a29173887541bdface45e662338f25d44">&#9670;&nbsp;</a></span>at() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classmu_1_1Vector.html">mu::Vector</a>&lt; N, T &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access an element within the vector </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">out</td><td>of range </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T&amp; </dd></dl>

</div>
</div>
<a id="a722613947d35b97a32f930ef6b70c364"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a722613947d35b97a32f930ef6b70c364">&#9670;&nbsp;</a></span>at() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classmu_1_1Vector.html">mu::Vector</a>&lt; N, T &gt;::at </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>const access an element within the vector </p>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">out</td><td>of range </td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const T&amp; </dd></dl>

</div>
</div>
<a id="a7d9d1c3218082522712fea2d5bc32868"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d9d1c3218082522712fea2d5bc32868">&#9670;&nbsp;</a></span>begin() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classmu_1_1Vector.html">mu::Vector</a>&lt; N, T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>iterator </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classmu_1_1Vector_a7d9d1c3218082522712fea2d5bc32868_icgraph.png" border="0" usemap="#classmu_1_1Vector_a7d9d1c3218082522712fea2d5bc32868_icgraph" alt=""/></div>
<map name="classmu_1_1Vector_a7d9d1c3218082522712fea2d5bc32868_icgraph" id="classmu_1_1Vector_a7d9d1c3218082522712fea2d5bc32868_icgraph">
<area shape="rect" id="node2" href="classmu_1_1Vector.html#a1fd85178491c5d9b5b67468bbed29e33" title="Construct a new Vector from an existing Vector of a different type. " alt="" coords="179,5,312,47"/>
<area shape="rect" id="node3" href="classmu_1_1Vector.html#a597ca2de6348a91e896f3f2296a5bcd2" title="flips this vector, i.e. reverses its elements " alt="" coords="179,71,312,112"/>
<area shape="rect" id="node4" href="classmu_1_1Vector.html#a3274e01fb6a31b8e750ef2bd32cf61a3" title="sort vector elements in ascending order " alt="" coords="179,136,312,177"/>
</map>
</div>

</div>
</div>
<a id="ab02fae7a5770b7980686695979b99a74"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab02fae7a5770b7980686695979b99a74">&#9670;&nbsp;</a></span>begin() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classmu_1_1Vector.html">mu::Vector</a>&lt; N, T &gt;::begin </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_iterator </dd></dl>

</div>
</div>
<a id="a9f7031194349b2570aeb0ef17fca454b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9f7031194349b2570aeb0ef17fca454b">&#9670;&nbsp;</a></span>dot()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename T&gt; </div>
<div class="memtemplate">
template&lt;typename U  = void, std::size_t N2, typename T2 &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::conditional_t&lt;std::is_same_v&lt;U, void&gt;, T, U&gt; <a class="el" href="classmu_1_1Vector.html">mu::Vector</a>&lt; N, T &gt;::dot </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmu_1_1Vector.html">Vector</a>&lt; N2, T2 &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>dot product of two vectors </p>
<p>For two Vectors of the same type, specifying the return type is optional. It will be of the type of the two Vectors by default.</p>
<p>For two Vectors of different types, specifying the return type is required. Otherwise the code will not compile. (this is to mitigate unwanted precision loss due to implicit casting. the trade-off is that the caller has to state the return type explicitly.)</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td></td></tr>
    <tr><td class="paramname">N2</td><td></td></tr>
    <tr><td class="paramname">T2</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::conditional_t&lt;std::is_same_v&lt;U, void&gt;, T, U&gt; </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classmu_1_1Vector_a9f7031194349b2570aeb0ef17fca454b_icgraph.png" border="0" usemap="#classmu_1_1Vector_a9f7031194349b2570aeb0ef17fca454b_icgraph" alt=""/></div>
<map name="classmu_1_1Vector_a9f7031194349b2570aeb0ef17fca454b_icgraph" id="classmu_1_1Vector_a9f7031194349b2570aeb0ef17fca454b_icgraph">
<area shape="rect" id="node2" href="classmu_1_1Vector.html#afe4d3c4dfa03eb4c8f9240f89c7f6139" title="euclidean vector length " alt="" coords="165,22,299,63"/>
</map>
</div>

</div>
</div>
<a id="a2caa4d33d64d146ca8c101d5005e025e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2caa4d33d64d146ca8c101d5005e025e">&#9670;&nbsp;</a></span>end() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">iterator <a class="el" href="classmu_1_1Vector.html">mu::Vector</a>&lt; N, T &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>iterator </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classmu_1_1Vector_a2caa4d33d64d146ca8c101d5005e025e_icgraph.png" border="0" usemap="#classmu_1_1Vector_a2caa4d33d64d146ca8c101d5005e025e_icgraph" alt=""/></div>
<map name="classmu_1_1Vector_a2caa4d33d64d146ca8c101d5005e025e_icgraph" id="classmu_1_1Vector_a2caa4d33d64d146ca8c101d5005e025e_icgraph">
<area shape="rect" id="node2" href="classmu_1_1Vector.html#a1fd85178491c5d9b5b67468bbed29e33" title="Construct a new Vector from an existing Vector of a different type. " alt="" coords="168,5,301,47"/>
<area shape="rect" id="node3" href="classmu_1_1Vector.html#a597ca2de6348a91e896f3f2296a5bcd2" title="flips this vector, i.e. reverses its elements " alt="" coords="168,71,301,112"/>
<area shape="rect" id="node4" href="classmu_1_1Vector.html#a3274e01fb6a31b8e750ef2bd32cf61a3" title="sort vector elements in ascending order " alt="" coords="168,136,301,177"/>
</map>
</div>

</div>
</div>
<a id="a3c733864c02356902b5d92e8fe2cd56c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c733864c02356902b5d92e8fe2cd56c">&#9670;&nbsp;</a></span>end() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const_iterator <a class="el" href="classmu_1_1Vector.html">mu::Vector</a>&lt; N, T &gt;::end </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="section return"><dt>Returns</dt><dd>const_iterator </dd></dl>

</div>
</div>
<a id="a597ca2de6348a91e896f3f2296a5bcd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a597ca2de6348a91e896f3f2296a5bcd2">&#9670;&nbsp;</a></span>flip()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmu_1_1Vector.html">mu::Vector</a>&lt; N, T &gt;::flip </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>flips this vector, i.e. reverses its elements </p>
<p>For example: (1,2,3) becomes (3,2,1) </p>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classmu_1_1Vector_a597ca2de6348a91e896f3f2296a5bcd2_icgraph.png" border="0" usemap="#classmu_1_1Vector_a597ca2de6348a91e896f3f2296a5bcd2_icgraph" alt=""/></div>
<map name="classmu_1_1Vector_a597ca2de6348a91e896f3f2296a5bcd2_icgraph" id="classmu_1_1Vector_a597ca2de6348a91e896f3f2296a5bcd2_icgraph">
<area shape="rect" id="node2" href="classmu_1_1Vector.html#a4cc2ef12039a1bc51b8e048a48054b49" title="returns a flipped vector " alt="" coords="164,5,297,47"/>
</map>
</div>

</div>
</div>
<a id="a4cc2ef12039a1bc51b8e048a48054b49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4cc2ef12039a1bc51b8e048a48054b49">&#9670;&nbsp;</a></span>flipped()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmu_1_1Vector.html">Vector</a>&lt;N, T&gt; <a class="el" href="classmu_1_1Vector.html">mu::Vector</a>&lt; N, T &gt;::flipped </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns a flipped vector </p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="classmu_1_1Vector.html#a597ca2de6348a91e896f3f2296a5bcd2">flip()</a> </dd></dl>
<dl class="section return"><dt>Returns</dt><dd>Vector&lt;N, T&gt; </dd></dl>

</div>
</div>
<a id="afe4d3c4dfa03eb4c8f9240f89c7f6139"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe4d3c4dfa03eb4c8f9240f89c7f6139">&#9670;&nbsp;</a></span>length()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename T&gt; </div>
<div class="memtemplate">
template&lt;class U  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">template float <a class="el" href="classmu_1_1Vector.html">mu::Vector</a>&lt; N, T &gt;::length&lt; float &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>euclidean vector length </p>
<p>returns the length as</p><ul>
<li>the type of this vector (default)</li>
<li>the explicitly stated type</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>U </dd></dl>

</div>
</div>
<a id="a0bcb8df801149ed1a5654a141aae14d7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bcb8df801149ed1a5654a141aae14d7">&#9670;&nbsp;</a></span>max()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classmu_1_1Vector.html">mu::Vector</a>&lt; N, T &gt;::max </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the max value of the vector </p>
<dl class="section return"><dt>Returns</dt><dd>T </dd></dl>

</div>
</div>
<a id="a21538d374825d19f7ce70a6649c03418"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21538d374825d19f7ce70a6649c03418">&#9670;&nbsp;</a></span>mean()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename T&gt; </div>
<div class="memtemplate">
template&lt;typename U  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">template float <a class="el" href="classmu_1_1Vector.html">mu::Vector</a>&lt; N, T &gt;::mean&lt; float &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>mean of all the elements of the vector </p>
<p>returns the mean as</p><ul>
<li>the type of this vector (default)</li>
<li>the explicitly stated type</li>
</ul>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>U </dd></dl>

</div>
</div>
<a id="a57ac0fa3add5609d667d37b934793acd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a57ac0fa3add5609d667d37b934793acd">&#9670;&nbsp;</a></span>min()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classmu_1_1Vector.html">mu::Vector</a>&lt; N, T &gt;::min </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>get the min value of the vector </p>
<dl class="section return"><dt>Returns</dt><dd>T </dd></dl>

</div>
</div>
<a id="aba86af220137e62f96c70b633655406d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba86af220137e62f96c70b633655406d">&#9670;&nbsp;</a></span>operator!=()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename T&gt; </div>
<div class="memtemplate">
template&lt;typename U  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">template bool <a class="el" href="classmu_1_1Vector.html">mu::Vector</a>&lt; N, T &gt;::operator!=&lt; int &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmu_1_1Vector.html">Vector</a>&lt; N, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>unequality operator </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool true if unequal, false if equal </dd></dl>

</div>
</div>
<a id="acb469ba14b1c71a664c89a2718111cd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb469ba14b1c71a664c89a2718111cd3">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename T&gt; </div>
<div class="memtemplate">
template&lt;typename U  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmu_1_1Vector.html">Vector</a>&lt;N, T&gt;&amp; <a class="el" href="classmu_1_1Vector.html">mu::Vector</a>&lt; N, T &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmu_1_1Vector.html">Vector</a>&lt; N, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>multiplication equal operator </p>
<p>subject to implicit conversions</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector&lt;N, T&gt;&amp; </dd></dl>

</div>
</div>
<a id="a5414c8c1ccbc49de284c9814c1abe5ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5414c8c1ccbc49de284c9814c1abe5ff">&#9670;&nbsp;</a></span>operator*=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename T&gt; </div>
<div class="memtemplate">
template&lt;class TScalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_arithmetic_v&lt;TScalar&gt;, <a class="el" href="classmu_1_1Vector.html">Vector</a>&lt;N, T&gt; &amp;&gt; <a class="el" href="classmu_1_1Vector.html">mu::Vector</a>&lt; N, T &gt;::operator*= </td>
          <td>(</td>
          <td class="paramtype">const TScalar &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>multiply a scalar with this vector </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TScalar</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::enable_if_t&lt;std::is_arithmetic_v&lt;TScalar&gt;,Vector&lt;N, T&gt; &amp;&gt; </dd></dl>

</div>
</div>
<a id="a2136aad610ab276d4dc903fc83a7278c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2136aad610ab276d4dc903fc83a7278c">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename T&gt; </div>
<div class="memtemplate">
template&lt;typename U  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmu_1_1Vector.html">Vector</a>&lt;N, T&gt;&amp; <a class="el" href="classmu_1_1Vector.html">mu::Vector</a>&lt; N, T &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmu_1_1Vector.html">Vector</a>&lt; N, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>plus equal operator </p>
<p>subject to implicit conversions</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector&lt;N, T&gt;&amp; </dd></dl>

</div>
</div>
<a id="aa19ffa96f0ea27c8c25fc854c50e18f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa19ffa96f0ea27c8c25fc854c50e18f7">&#9670;&nbsp;</a></span>operator+=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename T&gt; </div>
<div class="memtemplate">
template&lt;class TScalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_arithmetic_v&lt;TScalar&gt;, <a class="el" href="classmu_1_1Vector.html">Vector</a>&lt;N, T&gt; &amp;&gt; <a class="el" href="classmu_1_1Vector.html">mu::Vector</a>&lt; N, T &gt;::operator+= </td>
          <td>(</td>
          <td class="paramtype">const TScalar &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>add a scalar to this vector </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TScalar</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::enable_if_t&lt;std::is_arithmetic_v&lt;TScalar&gt;,Vector&lt;N, T&gt; &amp;&gt; </dd></dl>

</div>
</div>
<a id="a2aa6f7aa9010b7da656a88500f7fe543"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aa6f7aa9010b7da656a88500f7fe543">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename T&gt; </div>
<div class="memtemplate">
template&lt;typename U  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmu_1_1Vector.html">Vector</a>&lt;N, T&gt;&amp; <a class="el" href="classmu_1_1Vector.html">mu::Vector</a>&lt; N, T &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmu_1_1Vector.html">Vector</a>&lt; N, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>minus equal operator </p>
<p>subject to implicit conversions</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector&lt;N, T&gt;&amp; </dd></dl>

</div>
</div>
<a id="a00853b170ad61e3e0e662de55ed0e8db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00853b170ad61e3e0e662de55ed0e8db">&#9670;&nbsp;</a></span>operator-=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename T&gt; </div>
<div class="memtemplate">
template&lt;class TScalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_arithmetic_v&lt;TScalar&gt;, <a class="el" href="classmu_1_1Vector.html">Vector</a>&lt;N, T&gt; &amp;&gt; <a class="el" href="classmu_1_1Vector.html">mu::Vector</a>&lt; N, T &gt;::operator-= </td>
          <td>(</td>
          <td class="paramtype">const TScalar &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>subtract a scalar from every element of this vector </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TScalar</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::enable_if_t&lt;std::is_arithmetic_v&lt;TScalar&gt;, Vector&lt;N, T&gt; &amp;&gt; </dd></dl>

</div>
</div>
<a id="aa790abe736d6907382139e21fc29fa73"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa790abe736d6907382139e21fc29fa73">&#9670;&nbsp;</a></span>operator/=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename T&gt; </div>
<div class="memtemplate">
template&lt;typename U  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmu_1_1Vector.html">Vector</a>&lt;N, T&gt;&amp; <a class="el" href="classmu_1_1Vector.html">mu::Vector</a>&lt; N, T &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmu_1_1Vector.html">Vector</a>&lt; N, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>divison equal operator </p>
<p>subject to implicit conversions</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector&lt;N, T&gt;&amp; </dd></dl>

</div>
</div>
<a id="a3bc39f40d0f048d6586d3f5a4107bc52"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bc39f40d0f048d6586d3f5a4107bc52">&#9670;&nbsp;</a></span>operator/=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename T&gt; </div>
<div class="memtemplate">
template&lt;class TScalar &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::enable_if_t&lt;std::is_arithmetic_v&lt;TScalar&gt;, <a class="el" href="classmu_1_1Vector.html">Vector</a>&lt;N, T&gt; &amp;&gt; <a class="el" href="classmu_1_1Vector.html">mu::Vector</a>&lt; N, T &gt;::operator/= </td>
          <td>(</td>
          <td class="paramtype">const TScalar &amp;&#160;</td>
          <td class="paramname"><em>scalar</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>divide every element of this vector by a scalar </p>
<p>division by zero on integral types triggers an assert</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">TScalar</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">scalar</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::enable_if_t&lt;std::is_arithmetic_v&lt;TScalar&gt;, Vector&lt;N, T&gt; &amp;&gt; </dd></dl>

</div>
</div>
<a id="ad3c1a60d0cf755ac49f65b4bdd79e19c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3c1a60d0cf755ac49f65b4bdd79e19c">&#9670;&nbsp;</a></span>operator=() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmu_1_1Vector.html">Vector</a>&amp; <a class="el" href="classmu_1_1Vector.html">mu::Vector</a>&lt; N, T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmu_1_1Vector.html">Vector</a>&lt; N, T &gt; &amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmu_1_1Vector.html" title="A generic vector. ">Vector</a>&amp; </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classmu_1_1Vector_ad3c1a60d0cf755ac49f65b4bdd79e19c_icgraph.png" border="0" usemap="#classmu_1_1Vector_ad3c1a60d0cf755ac49f65b4bdd79e19c_icgraph" alt=""/></div>
<map name="classmu_1_1Vector_ad3c1a60d0cf755ac49f65b4bdd79e19c_icgraph" id="classmu_1_1Vector_ad3c1a60d0cf755ac49f65b4bdd79e19c_icgraph">
<area shape="rect" id="node2" href="classmu_1_1Vector.html#ac8eaa13db8e49bc60779bb8bcc7c958b" title="Construct a new Vector object from a single value. " alt="" coords="203,5,336,47"/>
</map>
</div>

</div>
</div>
<a id="a2797ec19947823a5464a6c1b42b7a707"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2797ec19947823a5464a6c1b42b7a707">&#9670;&nbsp;</a></span>operator=() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmu_1_1Vector.html">Vector</a>&amp; <a class="el" href="classmu_1_1Vector.html">mu::Vector</a>&lt; N, T &gt;::operator= </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classmu_1_1Vector.html">Vector</a>&lt; N, T &gt; &amp;&amp;&#160;</td>
          <td class="paramname"><em>other</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Move assignment operator. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">other</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="classmu_1_1Vector.html" title="A generic vector. ">Vector</a>&amp; </dd></dl>

</div>
</div>
<a id="a727d9670b23f8e43004ce09096b3bed0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a727d9670b23f8e43004ce09096b3bed0">&#9670;&nbsp;</a></span>operator==()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename T&gt; </div>
<div class="memtemplate">
template&lt;typename U  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">template bool <a class="el" href="classmu_1_1Vector.html">mu::Vector</a>&lt; N, T &gt;::operator==&lt; int &gt; </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classmu_1_1Vector.html">Vector</a>&lt; N, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>equality operator </p>
<p>comparisons between different arithmetic types are possible. they are subject to the c++ usual arithmetic conversions!</p>
<p>checked both ways for equality. First, casting both values to the type of the first argument, then casting both values to the type of the second argument.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">rhs</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>bool true if equal, false if unequal </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classmu_1_1Vector_a727d9670b23f8e43004ce09096b3bed0_icgraph.png" border="0" usemap="#classmu_1_1Vector_a727d9670b23f8e43004ce09096b3bed0_icgraph" alt=""/></div>
<map name="classmu_1_1Vector_a727d9670b23f8e43004ce09096b3bed0_icgraph" id="classmu_1_1Vector_a727d9670b23f8e43004ce09096b3bed0_icgraph">
<area shape="rect" id="node2" href="classmu_1_1Vector.html#aba86af220137e62f96c70b633655406d" title="unequality operator " alt="" coords="211,5,344,47"/>
</map>
</div>

</div>
</div>
<a id="a6be2cb910ade8cd39f922e23c6c3a69e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6be2cb910ade8cd39f922e23c6c3a69e">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; <a class="el" href="classmu_1_1Vector.html">mu::Vector</a>&lt; N, T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>access an element within the vector </p>
<p>does not throw an exception if <code>idx</code> is out of range</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>T&amp; </dd></dl>

</div>
</div>
<a id="a3cfd9124c9143e0cddacf54733169b68"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3cfd9124c9143e0cddacf54733169b68">&#9670;&nbsp;</a></span>operator[]() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const T&amp; <a class="el" href="classmu_1_1Vector.html">mu::Vector</a>&lt; N, T &gt;::operator[] </td>
          <td>(</td>
          <td class="paramtype">size_type&#160;</td>
          <td class="paramname"><em>idx</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>const access an element within the vector </p>
<p>does not throw an exception if <code>idx</code> is out of range</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idx</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>const T&amp; </dd></dl>

</div>
</div>
<a id="a1a6c382df2038bb89209087f1df0d60c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a6c382df2038bb89209087f1df0d60c">&#9670;&nbsp;</a></span>size()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">constexpr size_type <a class="el" href="classmu_1_1Vector.html">mu::Vector</a>&lt; N, T &gt;::size </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns the size of the vector </p>
<dl class="section return"><dt>Returns</dt><dd>size_type </dd></dl>

</div>
</div>
<a id="a345ca284147c9d01c541548256c67a49"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a345ca284147c9d01c541548256c67a49">&#9670;&nbsp;</a></span>sort()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename T&gt; </div>
<div class="memtemplate">
template&lt;typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="classmu_1_1Vector.html">mu::Vector</a>&lt; N, T &gt;::sort </td>
          <td>(</td>
          <td class="paramtype">const Compare &amp;&#160;</td>
          <td class="paramname"><em>comp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>sort vector elements by providing a condition </p>
<p>the condition should be a lambda function. it must return a bool</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Compare</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comp</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a268fadef8c3774945acc651f22d18e16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a268fadef8c3774945acc651f22d18e16">&#9670;&nbsp;</a></span>sorted() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmu_1_1Vector.html">Vector</a>&lt;N, T&gt; <a class="el" href="classmu_1_1Vector.html">mu::Vector</a>&lt; N, T &gt;::sorted </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>returns a sorted vector </p>
<dl class="section return"><dt>Returns</dt><dd>Vector&lt;N, T&gt; </dd></dl>

</div>
</div>
<a id="adbcfbe6e288f4e4087dbc36f4579dce0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adbcfbe6e288f4e4087dbc36f4579dce0">&#9670;&nbsp;</a></span>sorted() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename T&gt; </div>
<div class="memtemplate">
template&lt;typename Compare &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classmu_1_1Vector.html">Vector</a>&lt;N, T&gt; <a class="el" href="classmu_1_1Vector.html">mu::Vector</a>&lt; N, T &gt;::sorted </td>
          <td>(</td>
          <td class="paramtype">const Compare &amp;&#160;</td>
          <td class="paramname"><em>comp</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Compare</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">comp</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector&lt;N, T&gt; </dd></dl>

</div>
</div>
<a id="aa706bb810519c20ff759be4661d26371"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa706bb810519c20ff759be4661d26371">&#9670;&nbsp;</a></span>std()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename T&gt; </div>
<div class="memtemplate">
template&lt;class U  = T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">template float <a class="el" href="classmu_1_1Vector.html">mu::Vector</a>&lt; N, T &gt;::std&lt; float &gt; </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>calculates the standard deviation </p>
<p>\( \sigma = \sqrt{\frac{\sum(x_i - \mu)^2}{N}} \)</p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">U</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>U </dd></dl>

</div>
</div>
<a id="a5aaede8fa7e0cfa50b044fcaf89cf1f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5aaede8fa7e0cfa50b044fcaf89cf1f2">&#9670;&nbsp;</a></span>sum()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T <a class="el" href="classmu_1_1Vector.html">mu::Vector</a>&lt; N, T &gt;::sum </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>sum up all the elements of the vector </p>
<dl class="section return"><dt>Returns</dt><dd>T </dd></dl>
<div class="dynheader">
Here is the caller graph for this function:</div>
<div class="dyncontent">
<div class="center"><img src="classmu_1_1Vector_a5aaede8fa7e0cfa50b044fcaf89cf1f2_icgraph.png" border="0" usemap="#classmu_1_1Vector_a5aaede8fa7e0cfa50b044fcaf89cf1f2_icgraph" alt=""/></div>
<map name="classmu_1_1Vector_a5aaede8fa7e0cfa50b044fcaf89cf1f2_icgraph" id="classmu_1_1Vector_a5aaede8fa7e0cfa50b044fcaf89cf1f2_icgraph">
<area shape="rect" id="node2" href="classmu_1_1Vector.html#a21538d374825d19f7ce70a6649c03418" title="mean of all the elements of the vector " alt="" coords="185,5,318,47"/>
<area shape="rect" id="node3" href="classmu_1_1Vector.html#a9f7031194349b2570aeb0ef17fca454b" title="dot product of two vectors " alt="" coords="172,71,331,98"/>
<area shape="rect" id="node4" href="classmu_1_1Vector.html#aa706bb810519c20ff759be4661d26371" title="calculates the standard deviation " alt="" coords="172,122,331,149"/>
</map>
</div>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="ab10e7bdb6528c96a682b563532eeb6a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab10e7bdb6528c96a682b563532eeb6a2">&#9670;&nbsp;</a></span>operator<<</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;std::size_t N, typename T&gt; </div>
<div class="memtemplate">
template&lt;std::size_t Nn, class U &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::ostream&amp; operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;&#160;</td>
          <td class="paramname"><em>os</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classmu_1_1Vector.html">Vector</a>&lt; Nn, U &gt; &amp;&#160;</td>
          <td class="paramname"><em>v</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>print vector values </p>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">Nn</td><td></td></tr>
    <tr><td class="paramname">U</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">os</td><td></td></tr>
    <tr><td class="paramname">v</td><td></td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::ostream&amp; </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>/home/runner/work/mu/mu/include/mu/<a class="el" href="vector_8h_source.html">vector.h</a></li>
<li>/home/runner/work/mu/mu/coverage/explicit.cpp</li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><b>mu</b></li><li class="navelem"><a class="el" href="classmu_1_1Vector.html">Vector</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
